<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Shoulder MRI Viewer with Annotations (Coronal Match)</title>

  <!-- Cornerstone Libraries -->
  <script src="https://unpkg.com/cornerstone-core"></script>
  <script src="https://unpkg.com/cornerstone-tools"></script>
  <script src="https://unpkg.com/dicom-parser"></script>
  <script src="https://unpkg.com/cornerstone-wado-image-loader"></script>

  <style>
    body {
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      color: #fff;
      text-align: center;
    }
    #dicomImage {
      width: 512px;
      height: 512px;
      background-color: black;
      margin: auto;
      border-radius: 8px;
      position: relative;
    }
    #overlayCanvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
    }
    #controls {
      margin-top: 15px;
    }
    input[type=range] {
      width: 500px;
      max-width: 80vw;
    }
    .slice-info {
      margin-top: 8px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <h2>Shoulder MRI Viewer with Annotations</h2>
  <div style="position:relative; display:inline-block;">
    <div id="dicomImage"></div>
    <canvas id="overlayCanvas" width="512" height="512"></canvas>
  </div>
  <div id="controls">
    <input type="range" id="sliceSlider" min="0" max="279" value="0">
    <div class="slice-info">Slice <span id="currentSlice">1</span> / <span id="totalSlices">280</span></div>
  </div>

  <script>
    cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
    cornerstoneWADOImageLoader.webWorkerManager.initialize({
      webWorkerPath : 'https://unpkg.com/cornerstone-wado-image-loader/dist/cornerstoneWADOImageLoaderWebWorker.min.js',
      taskConfiguration: {
        decodeTask: {
          codecsPath: 'https://unpkg.com/cornerstone-wado-image-loader/dist/cornerstoneWADOImageLoaderCodecs.min.js'
        }
      }
    });

    const element = document.getElementById('dicomImage');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const ctx = overlayCanvas.getContext('2d');
    cornerstone.enable(element);

    const baseUrl = "https://raw.githubusercontent.com/im2famous4u/RadMentor/main/anatomy/mri-anatomy/test_shoulder/shoulder-dicom/";
    const jsonBaseUrl = "https://raw.githubusercontent.com/im2famous4u/RadMentor/main/anatomy/mri-anatomy/test_shoulder/";

    const files = {
      Deltoid: { url: jsonBaseUrl + "Deltoid.mrk.json", color: "red", points: [] },
      Humerus: { url: jsonBaseUrl + "Humerus.mrk.json", color: "blue", points: [] },
      Scapula: { url: jsonBaseUrl + "Scapula.mrk.json", color: "lime", points: [] }
    };

    const imageIds = [];
    for (let i = 1; i <= 280; i++) {
      const num = String(i).padStart(4, '0');
      imageIds.push(`wadouri:${baseUrl}IMG${num}.dcm`);
    }

    let currentImageIndex = 0;
    const slider = document.getElementById('sliceSlider');
    const currentSliceDisplay = document.getElementById('currentSlice');
    document.getElementById('totalSlices').textContent = imageIds.length;

    let slicePositions = []; // store IPP for all slices

    async function loadAnnotations() {
      for (const key in files) {
        const res = await fetch(files[key].url);
        const data = await res.json();
        files[key].points = data.markups[0].controlPoints.map(p => ({
          position: p.position, // [x, y, z] LPS
          label: p.label
        }));
      }
    }

    async function precomputeSlicePositions() {
      slicePositions = [];
      for (let i = 0; i < imageIds.length; i++) {
        const img = await cornerstone.loadAndCacheImage(imageIds[i]);
        const ipp = img.data.string('x00200032').split('\\').map(parseFloat); // ImagePositionPatient
        slicePositions.push(ipp); // store LPS of slice origin
      }
    }

    function lpsToPixel(positionLPS, image) {
      const ipp = image.data.string('x00200032').split('\\').map(parseFloat);
      const iop = image.data.string('x00200037').split('\\').map(parseFloat);
      const pxSpacing = image.data.string('x00280030').split('\\').map(parseFloat);
      const rowCosines = [iop[0], iop[1], iop[2]];
      const colCosines = [iop[3], iop[4], iop[5]];

      const dx = positionLPS[0] - ipp[0];
      const dy = positionLPS[1] - ipp[1];
      const dz = positionLPS[2] - ipp[2];

      const col = (dx * colCosines[0] + dy * colCosines[1] + dz * colCosines[2]) / pxSpacing[1];
      const row = (dx * rowCosines[0] + dy * rowCosines[1] + dz * rowCosines[2]) / pxSpacing[0];
      return { row, col };
    }

    function getSliceIndexForPoint(point) {
      // Coronal: match using X coordinate only
      let minDist = Infinity;
      let closestSlice = -1;
      for (let i = 0; i < slicePositions.length; i++) {
        const dx = Math.abs(slicePositions[i][0] - point[0]); // LPS X diff
        if (dx < minDist) {
          minDist = dx;
          closestSlice = i;
        }
      }
      return closestSlice;
    }

    function drawAnnotations(image, sliceIndex) {
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      ctx.font = "12px Arial";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;

      for (const key in files) {
        ctx.fillStyle = files[key].color;
        files[key].points.forEach(ptObj => {
          const sliceMatch = getSliceIndexForPoint(ptObj.position);
          if (sliceMatch === sliceIndex) {
            const ij = lpsToPixel(ptObj.position, image);
            ctx.beginPath();
            ctx.arc(ij.col, ij.row, 4, 0, 2 * Math.PI);
            ctx.fill();

            // Label with outline
            ctx.strokeText(ptObj.label, ij.col + 6, ij.row - 6);
            ctx.fillText(ptObj.label, ij.col + 6, ij.row - 6);
          }
        });
      }
    }

    async function loadAndViewImage(index) {
      if (index < 0 || index >= imageIds.length) return;
      currentImageIndex = index;
      slider.value = index;
      currentSliceDisplay.textContent = index + 1;
      const image = await cornerstone.loadAndCacheImage(imageIds[index]);
      cornerstone.displayImage(element, image);
      drawAnnotations(image, index);
    }

    element.addEventListener('wheel', (e) => {
      e.preventDefault();
      loadAndViewImage(currentImageIndex + (e.deltaY < 0 ? -1 : 1));
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'ArrowRight') loadAndViewImage(currentImageIndex + 1);
      else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') loadAndViewImage(currentImageIndex - 1);
    });

    slider.addEventListener('input', () => loadAndViewImage(parseInt(slider.value)));

    (async function init() {
      await loadAnnotations();
      await precomputeSlicePositions();
      loadAndViewImage(0);
    })();
  </script>
</body>
</html>
