<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Shoulder MRI Viewer with Annotations (Coronal Match + Tolerance)</title>

  <script src="https://unpkg.com/cornerstone-core@2.3.0/dist/cornerstone.js"></script>
  <script src="https://unpkg.com/cornerstone-tools@3.0.0/dist/cornerstoneTools.js"></script>
  <script src="https://unpkg.com/dicom-parser@1.8.7/dist/dicomParser.js"></script>
  <script src="https://unpkg.com/cornerstone-wado-image-loader@2.3.0/dist/cornerstoneWADOImageLoader.js"></script>

  <style>
    body {
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      color: #fff;
      text-align: center;
    }
    #dicomImage {
      width: 512px;
      height: 512px;
      background-color: black;
      margin: auto;
      border-radius: 8px;
      position: relative;
    }
    #overlayCanvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
    }
    #controls {
      margin-top: 15px;
    }
    input[type=range] {
      width: 500px;
      max-width: 80vw;
    }
    .slice-info {
      margin-top: 8px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <h2>Shoulder MRI Viewer with Annotations</h2>
  <div style="position:relative; display:inline-block;">
    <div id="dicomImage"></div>
    <canvas id="overlayCanvas" width="512" height="512"></canvas>
  </div>
  <div id="controls">
    <input type="range" id="sliceSlider" min="0" max="279" value="0">
    <div class="slice-info">Slice <span id="currentSlice">1</span> / <span id="totalSlices">280</span></div>
  </div>

  <script>
    cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
    cornerstoneWADOImageLoader.dicomParser = dicomParser;
    cornerstoneWADOImageLoader.webWorkerManager.initialize({
      webWorkerPath : 'https://unpkg.com/cornerstone-wado-image-loader@2.3.0/dist/cornerstoneWADOImageLoaderWebWorker.js',
      taskConfiguration: {
        'decodeTask': {
          codecsPath: 'https://unpkg.com/cornerstone-wado-image-loader@2.3.0/dist/cornerstoneWADOImageLoaderCodecs.js'
        }
      }
    });

    const element = document.getElementById('dicomImage');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const ctx = overlayCanvas.getContext('2d');
    cornerstone.enable(element);

    const baseUrl = "https://raw.githubusercontent.com/im2famous4u/RadMentor/main/anatomy/mri-anatomy/test_shoulder/shoulder-dicom/";
    const jsonBaseUrl = "https://raw.githubusercontent.com/im2famous4u/RadMentor/main/anatomy/mri-anatomy/test_shoulder/";

    const files = {
      Deltoid: { url: jsonBaseUrl + "F_2.mrk.json", color: "red", points: [] },
      Scapula: { url: jsonBaseUrl + "newscapula.mrk.json", color: "lime", points: [] }
    };

    const imageIds = [];
    for (let i = 1; i <= 280; i++) {
      const num = String(i).padStart(4, '0');
      imageIds.push(`wadouri:${baseUrl}IMG${num}.dcm`);
    }

    let currentImageIndex = 0;
    const slider = document.getElementById('sliceSlider');
    const currentSliceDisplay = document.getElementById('currentSlice');
    document.getElementById('totalSlices').textContent = imageIds.length;

    let slicePositions = [];
    let sliceThickness = 0;

    async function loadAnnotations() {
      for (const key in files) {
        const res = await fetch(files[key].url);
        const data = await res.json();
        files[key].points = data.markups[0].controlPoints.map(p => ({
          position: p.position,
          label: p.label
        }));
      }
    }

    async function precomputeSlicePositions() {
      console.log("Pre-computing slice positions...");
      slicePositions = [];
      for (let i = 0; i < imageIds.length; i++) {
        try {
            const img = await cornerstone.loadAndCacheImage(imageIds[i]);
            const ipp = img.data.string('x00200032').split('\\').map(parseFloat);
            slicePositions.push(ipp);
        } catch (error) {
            console.error(`Failed to load image ${imageIds[i]}:`, error);
        }
      }
      if (slicePositions.length >= 2) {
        // --- FIX ---
        // For Coronal view, slice position changes along the Y-axis [1].
        sliceThickness = Math.abs(slicePositions[1][1] - slicePositions[0][1]);
      }
      console.log("Slice positions computed. Slice thickness:", sliceThickness);
    }

    function lpsToPixel(positionLPS, image) {
      const ipp = image.data.string('x00200032').split('\\').map(parseFloat);
      const iop = image.data.string('x00200037').split('\\').map(parseFloat);
      const pxSpacing = image.data.string('x00280030').split('\\').map(parseFloat);
      
      const rowCosines = [iop[0], iop[1], iop[2]];
      const colCosines = [iop[3], iop[4], iop[5]];

      const vec = [
        positionLPS[0] - ipp[0],
        positionLPS[1] - ipp[1],
        positionLPS[2] - ipp[2]
      ];

      const col = (vec[0] * colCosines[0] + vec[1] * colCosines[1] + vec[2] * colCosines[2]) / pxSpacing[1];
      const row = (vec[0] * rowCosines[0] + vec[1] * rowCosines[1] + vec[2] * rowCosines[2]) / pxSpacing[0];
      
      return { row, col };
    }

    function getSliceIndexForPoint(point) {
      let minDist = Infinity;
      let closestSlice = -1;

      for (let i = 0; i < slicePositions.length; i++) {
        // --- FIX ---
        // Match the annotation point to the slice using the Y-axis [1] for Coronal view.
        const dist = Math.abs(slicePositions[i][1] - point[1]); 
        if (dist < minDist) {
          minDist = dist;
          closestSlice = i;
        }
      }

      // Check if the point is within half the slice thickness of the slice's center
      if (minDist <= sliceThickness / 2) {
        return closestSlice;
      } else {
        return -1; // Point is not on any slice
      }
    }

    function drawAnnotations(image, sliceIndex) {
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      ctx.font = "12px Arial";
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;

      for (const key in files) {
        ctx.fillStyle = files[key].color;
        files[key].points.forEach(ptObj => {
          const sliceMatch = getSliceIndexForPoint(ptObj.position);
          if (sliceMatch === sliceIndex) {
            const ij = lpsToPixel(ptObj.position, image);
            ctx.beginPath();
            ctx.arc(ij.col, ij.row, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeText(ptObj.label, ij.col + 6, ij.row - 6);
            ctx.fillText(ptObj.label, ij.col + 6, ij.row - 6);
          }
        });
      }
    }

    async function loadAndViewImage(index) {
      if (index < 0 || index >= imageIds.length) return;
      currentImageIndex = index;
      slider.value = index;
      currentSliceDisplay.textContent = index + 1;
      try {
        const image = await cornerstone.loadAndCacheImage(imageIds[index]);
        cornerstone.displayImage(element, image);
        drawAnnotations(image, index);
      } catch(err) {
        console.error("Error loading or displaying image:", err);
      }
    }

    element.addEventListener('wheel', (e) => {
      e.preventDefault();
      const newIndex = currentImageIndex + (e.deltaY < 0 ? -1 : 1);
      loadAndViewImage(newIndex);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'ArrowRight') loadAndViewImage(currentImageIndex + 1);
      else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') loadAndViewImage(currentImageIndex - 1);
    });

    slider.addEventListener('input', (e) => loadAndViewImage(parseInt(e.target.value, 10)));

    (async function init() {
      try {
        await loadAnnotations();
        await precomputeSlicePositions();
        loadAndViewImage(0);
      } catch (err) {
        console.error("Initialization failed:", err);
      }
    })();
  </script>
</body>
</html>
