<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Shoulder MRI Viewer with Annotations (Final Version)</title>
  <script src="https://unpkg.com/cornerstone-core"></script>
  <script src="https://unpkg.com/cornerstone-tools"></script>
  <script src="https://unpkg.com/dicom-parser"></script>
  <script src="https://unpkg.com/cornerstone-wado-image-loader"></script>
  <style>
    body {
      background-color: #1a1a1a;
      font-family: Arial, sans-serif;
      color: #fff;
      text-align: center;
    }
    #dicomImage {
      width: 512px;
      height: 512px;
      background-color: black;
      margin: auto;
      border-radius: 8px;
      position: relative;
    }
    #overlayCanvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      z-index: 10;
    }
    #controls {
      margin-top: 15px;
    }
    input[type=range] {
      width: 500px;
      max-width: 80vw;
    }
    .slice-info {
      margin-top: 8px;
      font-size: 14px;
      color: #ccc;
    }
    #debugPanel {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      text-align: left;
      max-width: 300px;
      max-height: 200px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h2>Shoulder MRI Viewer with Annotations</h2>
  <div style="position:relative; display:inline-block;">
    <div id="dicomImage"></div>
    <canvas id="overlayCanvas" width="512" height="512"></canvas>
  </div>
  <div id="controls">
    <input type="range" id="sliceSlider" min="0" max="279" value="0">
    <div class="slice-info">Slice <span id="currentSlice">1</span> / <span id="totalSlices">280</span></div>
  </div>
  
  <div id="debugPanel">
    <strong>Debug Info:</strong>
    <div id="debugContent"></div>
  </div>

  <script>
    cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
    cornerstoneWADOImageLoader.webWorkerManager.initialize({
      webWorkerPath : 'https://unpkg.com/cornerstone-wado-image-loader/dist/cornerstoneWADOImageLoaderWebWorker.min.js',
      taskConfiguration: {
        decodeTask: {
          codecsPath: 'https://unpkg.com/cornerstone-wado-image-loader/dist/cornerstoneWADOImageLoaderCodecs.min.js'
        }
      }
    });
    
    const element = document.getElementById('dicomImage');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const ctx = overlayCanvas.getContext('2d');
    const debugContent = document.getElementById('debugContent');
    
    cornerstone.enable(element);
    
    const baseUrl = "https://raw.githubusercontent.com/im2famous4u/RadMentor/main/anatomy/mri-anatomy/test_shoulder/shoulder-dicom/";
    const jsonBaseUrl = "https://raw.githubusercontent.com/im2famous4u/RadMentor/main/anatomy/mri-anatomy/test_shoulder/";
    
    const files = {
      Deltoid: { url: jsonBaseUrl + "F_2.mrk.json", color: "red", points: [] },
      Scapula: { url: jsonBaseUrl + "newscapula.mrk.json", color: "lime", points: [] }
    };
    
    const imageIds = [];
    for (let i = 1; i <= 280; i++) {
      const num = String(i).padStart(4, '0');
      imageIds.push(`wadouri:${baseUrl}IMG${num}.dcm`);
    }
    
    let currentImageIndex = 0;
    const slider = document.getElementById('sliceSlider');
    const currentSliceDisplay = document.getElementById('currentSlice');
    document.getElementById('totalSlices').textContent = imageIds.length;
    
    let sliceInfo = []; 
    let sliceThickness = 0;

    // --- CHANGE 1: Add a "ready" flag ---
    let isReady = false;
    
    function debugLog(message) {
      console.log(message);
      const msg = typeof message === 'object' ? JSON.stringify(message) : message;
      debugContent.innerHTML += `<div>${msg}</div>`;
      debugContent.scrollTop = debugContent.scrollHeight;
    }
    
    function resizeOverlayCanvas() {
      overlayCanvas.style.width = element.clientWidth + 'px';
      overlayCanvas.style.height = element.clientHeight + 'px';
      overlayCanvas.width = element.clientWidth;
      overlayCanvas.height = element.clientHeight;
    }
    
    async function loadAnnotations() {
      debugLog("Loading annotations...");
      for (const key in files) {
        try {
          const res = await fetch(files[key].url);
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          const data = await res.json();
          files[key].points = data.markups[0].controlPoints.map(p => ({
            position: p.position,
            label: p.label
          }));
          debugLog(`Loaded ${files[key].points.length} points for ${key}`);
        } catch (e) {
          debugLog(`Error loading ${key} annotations: ${e.message}`);
        }
      }
    }
    
    async function precomputeSlicePositions() {
        debugLog("Precomputing slice information...");
        sliceInfo = [];
        for (let i = 0; i < imageIds.length; i++) {
            try {
                const img = await cornerstone.loadAndCacheImage(imageIds[i]);
                const ipp = img.data.string('x00200032').split('\\').map(parseFloat);
                const iop = img.data.string('x00200037').split('\\').map(parseFloat);
                const rowCosines = [iop[0], iop[1], iop[2]];
                const colCosines = [iop[3], iop[4], iop[5]];
                const normal = [
                    rowCosines[1] * colCosines[2] - rowCosines[2] * colCosines[1],
                    rowCosines[2] * colCosines[0] - rowCosines[0] * colCosines[2],
                    rowCosines[0] * colCosines[1] - rowCosines[1] * colCosines[0]
                ];
                sliceInfo[i] = { position: ipp, orientation: iop, normal: normal };
            } catch (e) {
                debugLog(`Error precomputing slice info ${i}: ${e.message}`);
            }
        }
        if (sliceInfo.length >= 2 && sliceInfo[0] && sliceInfo[1]) {
            const pos0 = sliceInfo[0].position;
            const pos1 = sliceInfo[1].position;
            const dx = pos1[0] - pos0[0];
            const dy = pos1[1] - pos0[1];
            const dz = pos1[2] - pos0[2];
            sliceThickness = Math.sqrt(dx*dx + dy*dy + dz*dz);
            debugLog(`Computed slice thickness: ${sliceThickness}`);
        } else {
            debugLog("Could not compute slice thickness");
        }
    }
    
    function lpsToPixel(positionLPS, image) {
      const ipp = image.data.string('x00200032').split('\\').map(parseFloat);
      const iop = image.data.string('x00200037').split('\\').map(parseFloat);
      const pxSpacing = image.data.string('x00280030').split('\\').map(parseFloat);
      const rowCosines = [iop[0], iop[1], iop[2]];
      const colCosines = [iop[3], iop[4], iop[5]];
      const dx = positionLPS[0] - ipp[0];
      const dy = positionLPS[1] - ipp[1];
      const dz = positionLPS[2] - ipp[2];
      const col = (dx * colCosines[0] + dy * colCosines[1] + dz * colCosines[2]) / pxSpacing[1];
      const row = (dx * rowCosines[0] + dy * rowCosines[1] + dz * rowCosines[2]) / pxSpacing[0];
      return { row, col };
    }
    
    function getSliceIndexForPoint(point) {
        let minDist = Infinity;
        let closestSlice = -1;
        for (let i = 0; i < sliceInfo.length; i++) {
            if (!sliceInfo[i]) continue;
            const slice = sliceInfo[i];
            const ipp = slice.position;
            const normal = slice.normal;
            const vector = [ point[0] - ipp[0], point[1] - ipp[1], point[2] - ipp[2] ];
            const distance = Math.abs(vector[0] * normal[0] + vector[1] * normal[1] + vector[2] * normal[2]);
            if (distance < minDist) {
                minDist = distance;
                closestSlice = i;
            }
        }
        const tolerance = sliceThickness / 2;
        if (minDist <= tolerance) {
            return closestSlice;
        } else {
            return -1;
        }
    }
    
    function drawAnnotations(image, sliceIndex) {
      // --- CHANGE 3: Check the flag before drawing ---
      if (!isReady) {
        debugLog("Not ready to draw, pre-computation is not complete.");
        return;
      }

      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      const viewport = cornerstone.getViewport(element);
      if (!viewport) return;
      
      let pointsDrawn = 0;
      for (const key in files) {
        ctx.fillStyle = files[key].color;
        files[key].points.forEach((ptObj) => {
          const sliceMatch = getSliceIndexForPoint(ptObj.position);
          if (sliceMatch === sliceIndex) {
            const ij = lpsToPixel(ptObj.position, image);
            if (ij.row < 0 || ij.col < 0) return;
            const x = ij.col * viewport.scale + viewport.translation.x;
            const y = ij.row * viewport.scale + viewport.translation.y;
            
            ctx.beginPath();
            ctx.arc(x, y, 4 * viewport.scale, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.font = `${Math.max(12, 12 * viewport.scale)}px Arial`;
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.strokeText(ptObj.label, x + 6, y - 6);
            ctx.fillText(ptObj.label, x + 6, y - 6);
            pointsDrawn++;
          }
        });
      }
      if (pointsDrawn > 0) {
        debugLog(`Drew ${pointsDrawn} annotations for slice ${sliceIndex}`);
      }
    }

    async function loadAndViewImage(index) {
      if (index < 0 || index >= imageIds.length) return;
      currentImageIndex = index;
      slider.value = index;
      currentSliceDisplay.textContent = index + 1;
      try {
        const image = await cornerstone.loadAndCacheImage(imageIds[index]);
        cornerstone.displayImage(element, image);
      } catch (e) {
        debugLog(`Error loading image ${index}: ${e.message}`);
      }
    }
    
    element.addEventListener('wheel', (e) => {
      e.preventDefault();
      loadAndViewImage(currentImageIndex + (e.deltaY < 0 ? -1 : 1));
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'ArrowRight') loadAndViewImage(currentImageIndex + 1);
      else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') loadAndViewImage(currentImageIndex - 1);
    });
    
    slider.addEventListener('input', () => loadAndViewImage(parseInt(slider.value)));
    
    element.addEventListener('cornerstoneimagerendered', () => {
      resizeOverlayCanvas();
      const image = cornerstone.getImage(element);
      if (image) {
        drawAnnotations(image, currentImageIndex);
      }
    });
    
    window.addEventListener('resize', () => {
        resizeOverlayCanvas();
        const image = cornerstone.getImage(element);
        if (image) {
            drawAnnotations(image, currentImageIndex);
        }
    });
    
    (async function init() {
      debugLog("Initializing application");
      try {
        await loadAnnotations();
        await precomputeSlicePositions();

        // --- CHANGE 2: Set the flag to true ---
        isReady = true; 
        
        loadAndViewImage(0);
        debugLog("Initialization complete");
      } catch (e) {
        debugLog(`Initialization error: ${e.message}`);
      }
    })();
  </script>
</body>
</html>
