import React, { useState, useEffect } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, arrayRemove } from 'firebase/firestore';

// Global variables provided by the Canvas environment
// Ensure these are defined, otherwise use default values for local development/testing
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Mock Quiz Questions
const quizQuestions = [
  {
    id: 'Q001',
    text: 'Which imaging modality uses X-rays to create detailed images of bones and soft tissues?',
    options: ['MRI', 'Ultrasound', 'CT Scan', 'Nuclear Medicine'],
    correctAnswer: 'CT Scan',
  },
  {
    id: 'Q002',
    text: 'What does MRI stand for?',
    options: ['Magnetic Resonance Imaging', 'Medical Radiation Instrument', 'Molecular Radiography Index', 'Magnetism Resonance Indicator'],
    correctAnswer: 'Magnetic Resonance Imaging',
  },
  {
    id: 'Q003',
    text: 'Which imaging technique is best for visualizing a fetus during pregnancy?',
    options: ['CT Scan', 'X-ray', 'Ultrasound', 'PET Scan'],
    correctAnswer: 'Ultrasound',
  },
  {
    id: 'Q004',
    text: 'What type of radiation is used in a PET scan?',
    options: ['Alpha particles', 'Beta particles', 'Gamma rays', 'Positrons'],
    correctAnswer: 'Positrons',
  },
];

function App() {
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [userProgress, setUserProgress] = useState({ completedQuestions: [], bookmarkedQuestions: [] });
  const [message, setMessage] = useState('');
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [selectedOption, setSelectedOption] = useState(null);
  const [answerFeedback, setAnswerFeedback] = useState(null); // 'correct', 'incorrect', null

  useEffect(() => {
    // Initialize Firebase and set up authentication
    const initFirebase = async () => {
      try {
        const app = initializeApp(firebaseConfig);
        const firestoreDb = getFirestore(app);
        const firebaseAuth = getAuth(app);

        setDb(firestoreDb);
        setAuth(firebaseAuth);

        // Listen for authentication state changes
        onAuthStateChanged(firebaseAuth, async (user) => {
          if (user) {
            setUserId(user.uid);
            console.log('User authenticated:', user.uid);
            // Once authenticated, load user's progress
            await loadUserProgress(firestoreDb, user.uid);
          } else {
            console.log('No user, attempting anonymous sign-in or custom token sign-in.');
            if (initialAuthToken) {
              await signInWithCustomToken(firebaseAuth, initialAuthToken);
            } else {
              await signInAnonymously(firebaseAuth);
            }
          }
          setLoading(false); // Authentication process is done
        });
      } catch (error) {
        console.error("Error initializing Firebase:", error);
        setMessage(`Error initializing Firebase: ${error.message}`);
        setLoading(false);
      }
    };

    initFirebase();
  }, []); // Run only once on component mount

  // Function to load user progress from Firestore
  const loadUserProgress = async (firestoreDb, currentUserId) => {
    if (!firestoreDb || !currentUserId) {
      console.log("Firestore DB or User ID not ready to load progress.");
      return;
    }

    try {
      // Path for private user data: /artifacts/{appId}/users/{userId}/quizProgress
      const userDocRef = doc(firestoreDb, `artifacts/${appId}/users/${currentUserId}/quizProgress`, 'myProgress');
      const docSnap = await getDoc(userDocRef);

      if (docSnap.exists()) {
        const data = docSnap.data();
        setUserProgress({
          completedQuestions: data.completedQuestions || [],
          bookmarkedQuestions: data.bookmarkedQuestions || []
        });
        setMessage('User progress loaded successfully!');
      } else {
        console.log("No existing user progress document found, creating a new one.");
        // Create initial document if it doesn't exist
        await setDoc(userDocRef, { completedQuestions: [], bookmarkedQuestions: [] });
        setMessage('New user progress document created.');
      }
    } catch (error) {
      console.error("Error loading user progress:", error);
      setMessage(`Error loading user progress: ${error.message}`);
    }
  };

  // Function to save a completed question
  const saveCompletedQuestion = async (questionId) => {
    if (!db || !userId) {
      setMessage('Firebase not initialized or user not authenticated yet.');
      return;
    }

    try {
      const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/quizProgress`, 'myProgress');
      await updateDoc(userDocRef, {
        completedQuestions: arrayUnion(questionId) // Add questionId if not already present
      });
      setUserProgress(prev => ({
        ...prev,
        completedQuestions: [...new Set([...prev.completedQuestions, questionId])] // Update local state
      }));
      // setMessage(`Question ${questionId} marked as completed!`); // Removed to avoid conflicting with answer feedback
    } catch (error) {
      console.error("Error saving completed question:", error);
      setMessage(`Error saving completed question: ${error.message}`);
    }
  };

  // Function to toggle a bookmarked question
  const toggleBookmarkQuestion = async (questionId) => {
    if (!db || !userId) {
      setMessage('Firebase not initialized or user not authenticated yet.');
      return;
    }

    try {
      const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/quizProgress`, 'myProgress');
      const isBookmarked = userProgress.bookmarkedQuestions.includes(questionId);

      if (isBookmarked) {
        await updateDoc(userDocRef, {
          bookmarkedQuestions: arrayRemove(questionId) // Remove if already bookmarked
        });
        setUserProgress(prev => ({
          ...prev,
          bookmarkedQuestions: prev.bookmarkedQuestions.filter(id => id !== questionId) // Update local state
        }));
        setMessage(`Question ${questionId} unbookmarked.`);
      } else {
        await updateDoc(userDocRef, {
          bookmarkedQuestions: arrayUnion(questionId) // Add if not bookmarked
        });
        setUserProgress(prev => ({
          ...prev,
          bookmarkedQuestions: [...new Set([...prev.bookmarkedQuestions, questionId])] // Update local state
        }));
        setMessage(`Question ${questionId} bookmarked!`);
      }
    } catch (error) {
      console.error("Error toggling bookmark:", error);
      setMessage(`Error toggling bookmark: ${error.message}`);
    }
  };

  const handleOptionSelect = (option) => {
    setSelectedOption(option);
    setAnswerFeedback(null); // Clear previous feedback
  };

  const handleSubmitAnswer = () => {
    const currentQuestion = quizQuestions[currentQuestionIndex];
    if (selectedOption === currentQuestion.correctAnswer) {
      setAnswerFeedback('correct');
      saveCompletedQuestion(currentQuestion.id); // Save as completed if correct
      setMessage(`Correct! Question ${currentQuestion.id} completed.`);
    } else {
      setAnswerFeedback('incorrect');
      setMessage(`Incorrect. Try again or move to the next question.`);
    }
  };

  const handleNextQuestion = () => {
    if (currentQuestionIndex < quizQuestions.length - 1) {
      setCurrentQuestionIndex(prevIndex => prevIndex + 1);
      setSelectedOption(null); // Reset selected option for new question
      setAnswerFeedback(null); // Clear feedback
      setMessage(''); // Clear general message
    } else {
      setMessage('You have completed all questions!');
    }
  };

  const handlePreviousQuestion = () => {
    if (currentQuestionIndex > 0) {
      setCurrentQuestionIndex(prevIndex => prevIndex - 1);
      setSelectedOption(null); // Reset selected option for new question
      setAnswerFeedback(null); // Clear feedback
      setMessage(''); // Clear general message
    } else {
      setMessage('You are at the first question.');
    }
  };

  const currentQuestion = quizQuestions[currentQuestionIndex];
  const isCurrentQuestionBookmarked = userProgress.bookmarkedQuestions.includes(currentQuestion.id);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-100">
        <div className="text-lg font-semibold text-gray-700">Loading Firebase and authenticating...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4 sm:p-6 lg:p-8 flex flex-col items-center justify-center font-sans">
      <div className="max-w-4xl w-full bg-white rounded-xl shadow-2xl p-6 sm:p-8 lg:p-10 border border-gray-200">
        <h1 className="text-3xl sm:text-4xl font-extrabold text-center text-indigo-800 mb-6">
          Radiology Quiz
        </h1>
        <p className="text-center text-gray-600 mb-8">
          Your unique user ID: <span className="font-mono text-sm bg-gray-100 p-1 rounded">{userId || 'N/A'}</span>
        </p>

        {message && (
          <div className={`px-4 py-3 rounded relative mb-6 ${answerFeedback === 'correct' ? 'bg-green-100 border-green-400 text-green-700' : answerFeedback === 'incorrect' ? 'bg-red-100 border-red-400 text-red-700' : 'bg-blue-100 border-blue-400 text-blue-700'}`} role="alert">
            <span className="block sm:inline">{message}</span>
          </div>
        )}

        {/* Quiz Section */}
        <div className="bg-purple-50 p-6 rounded-lg shadow-inner border border-purple-200 mb-8">
          <h2 className="text-2xl font-bold text-purple-800 mb-4">
            Question {currentQuestionIndex + 1} of {quizQuestions.length}
          </h2>
          <p className="text-lg text-gray-800 mb-6">{currentQuestion.text}</p>

          <div className="space-y-3 mb-6">
            {currentQuestion.options.map((option, index) => (
              <button
                key={index}
                className={`w-full text-left p-3 rounded-lg border-2 transition duration-200 ease-in-out
                  ${selectedOption === option
                    ? 'bg-purple-600 text-white border-purple-700 shadow-md'
                    : 'bg-white text-gray-800 border-gray-300 hover:bg-gray-50'
                  }
                  ${answerFeedback === 'correct' && option === currentQuestion.correctAnswer ? 'bg-green-200 border-green-500' : ''}
                  ${answerFeedback === 'incorrect' && option === selectedOption ? 'bg-red-200 border-red-500' : ''}
                `}
                onClick={() => handleOptionSelect(option)}
                disabled={answerFeedback !== null} // Disable options after submission
              >
                {option}
              </button>
            ))}
          </div>

          <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
            <button
              onClick={handleSubmitAnswer}
              className="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
              disabled={selectedOption === null || answerFeedback !== null}
            >
              Submit Answer
            </button>
            <button
              onClick={() => toggleBookmarkQuestion(currentQuestion.id)}
              className={`w-full sm:w-auto font-bold py-2 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105
                ${isCurrentQuestionBookmarked ? 'bg-yellow-500 hover:bg-yellow-600 text-white' : 'bg-gray-200 hover:bg-gray-300 text-gray-800'}
              `}
            >
              {isCurrentQuestionBookmarked ? 'Bookmarked!' : 'Toggle Bookmark'}
            </button>
          </div>
          <div className="flex justify-between mt-6">
            <button
              onClick={handlePreviousQuestion}
              className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
              disabled={currentQuestionIndex === 0}
            >
              Previous
            </button>
            <button
              onClick={handleNextQuestion}
              className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
              disabled={currentQuestionIndex === quizQuestions.length - 1}
            >
              Next
            </button>
          </div>
        </div>

        {/* Progress Display Section */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="bg-green-50 p-5 rounded-lg shadow-inner border border-green-200">
            <h2 className="text-xl font-bold text-green-800 mb-4">Completed Questions</h2>
            <div className="flex flex-wrap gap-2">
              {userProgress.completedQuestions.length > 0 ? (
                userProgress.completedQuestions.map(qId => (
                  <span key={qId} className="bg-green-200 text-green-800 text-sm font-semibold px-3 py-1 rounded-full shadow-sm">
                    {qId}
                  </span>
                ))
              ) : (
                <p className="text-gray-500">No questions completed yet.</p>
              )}
            </div>
          </div>

          <div className="bg-yellow-50 p-5 rounded-lg shadow-inner border border-yellow-200">
            <h2 className="text-xl font-bold text-yellow-800 mb-4">Bookmarked Questions</h2>
            <div className="flex flex-wrap gap-2">
              {userProgress.bookmarkedQuestions.length > 0 ? (
                userProgress.bookmarkedQuestions.map(qId => (
                  <span key={qId} className="bg-yellow-200 text-yellow-800 text-sm font-semibold px-3 py-1 rounded-full shadow-sm">
                    {qId}
                  </span>
                ))
              ) : (
                <p className="text-gray-500">No questions bookmarked yet.</p>
              )}
            </div>
          </div>
        </div>

        <p className="text-center text-gray-500 text-sm mt-8">
          This app automatically handles authentication. Your progress is saved using the User ID shown above.
        </p>
      </div>
    </div>
  );
}

export default App;
